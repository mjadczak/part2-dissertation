\chapter{Evaluation}\label{ch:eval}

Correctness, performance, and ease of use are three important dimensions along which this project was evaluated.

This section outlines the steps taken to test these, and the results obtained.
The data collection and processing methodology is touched upon.
Known limitations in the implementation are also mentioned.


\section{Overall results}\label{sec:eval:overall}



\section{Correctness testing}\label{sec:eval:correctness}

\section{Known limitations}\label{sec:eval:limitations}

\todo{include capability matrices? Maybe construct one for this implementation? (https://beam.apache.org/documentation/runners/capability-matrix/)}

\section{Approach to empirical evaluation}\label{sec:eval:approach}

\subsection{Test environment}\label{sec:eval:approach:environment}

\subsection{Data collection methodologies}\label{sec:eval:approach:collection}

\subsection{The Twitter example}\label{sec:eval:approach:twitter}

\section{Code comparison}\label{sec:eval:code}

\todo{below pasted from IMPL}


Instead of directly coupling watermark management to reading from a Source (which only makes sense for some sources), we can now use general-use Transforms which can provide watermark estimation or transformation algorithms in a standard way in cases where we must generate our own watermarks.

For instance, in the Twitter example in \cref{eval}, the Twitter stream contains no intrinsic watermark information in the metadata---a tweet must be processed to determine its timestamp.
The stream contains no watermark information.

In the Java implementation of the example, a custom Source had to be written which combined responsibility for reading tweets from a network stream, parsing them, extracting a timestamp, and calculating a watermark for the Collection, in one large, tightly coupled class.

In the Elixir version, on the other hand, the root transform only had to worry about reading tweets from the network and parsing their JSON.
It output them with a minimal timestamp and held its own watermark to the minimal timestamp.
A further Transform extracted the timestamp from the data and assigned it to the elements, still in the original domain.
This was valid since timestamps were being shifted forward.
A further yet Transform used the element timestamps to estimate a watermark and output these elements into the new watermark domain.
This Transform was a standard Transform which could be used to estimate the watermark of any stream of timestamped elements.


\section{Performance evaluation}\label{sec:eval:performance}

\section{Resource consumption}\label{sec:eval:resource}

\section{Latency evaluation}\label{sec:eval:latency}

